// Code for this lambda broken into several modules 
import { prepareAndCallLLM } from './prepare-and-call-llm.mjs';
import { savePrompt } from './database-helpers.mjs';
import { formatLLMMessage } from './llm-formatting-helpers.mjs';

import { makeApartmentSearchToolCalls } from './tools/apartment-search/tools.mjs';
import { makeRestaurantOrderingToolCalls } from './tools/restaurant-ordering/tools.mjs';

import { FSDB } from "file-system-db"; 

/**
 * getSessionDetails
 * 
 * Get the session details (prompt, tools, user context) from 
 * the database given the callSid which is the id generated by Twilio 
 * and used as the session ID. Session needed at each turn.
 */
const getSessionDetails = async (callSid) => {
    try {        
        
        const crSession = new FSDB(`../data/sessions/${callSid}/session.json`, false);
        const sessionDetails = crSession.get(callSid)

        if(!sessionDetails) {
            console.error("No session details found for callSid: ", callSid);
            return;
        }
        
        return sessionDetails;

    } catch (error) {
        
        console.error("Error getting call connection: ", error);
        throw error;

    }
};

/**
 * This function handles the incoming messages from the Twilio ConversationRelay server.
 * 
 * The body of the message is a JSON object that contains the type of event and other
 * information. The type of event can be "prompt", "dtmf", "setup", "end", or "error".
 * 
 * This function is called from the onMessage handler in the WebSocket server.
 */
export const defaultWebsocketHandler = async (callSid, socket, body, toolCallCompletion, clientSocket) => { 

    //console.info("defaultWebsocketHandler and body => ", body);

    let now = Date.now();
    let currentMessage = { ...body, "ts": now };

    try {


        if (body?.type === "info" && clientSocket !== null) {
            
            clientSocket.send(JSON.stringify(currentMessage));
        }        

        if (body?.type === "error") {
            console.error("Error event received from ConversationRelay server: ", body.description);
        }

        // Text prompts and dtmf events sent via WebSockets 
        // and tool call completion events follow the same steps and call the LLM
        if (body?.type === "prompt" || body?.type === "dtmf") {                        

            console.info("Received prompt or dtmf => ", currentMessage);

            const sessionDetails = await getSessionDetails(callSid);
            
            if (clientSocket !== null) {
                clientSocket.send(JSON.stringify(currentMessage));
            }

            const llmResult = await prepareAndCallLLM({                
                callSid: callSid, 
                sessionDetails: sessionDetails, // Object from database session details
                socket: socket, 
                body: body, 
                toolCallCompletion: toolCallCompletion,
                clientSocket: clientSocket
            });
                

            console.info("llmResult\n" + JSON.stringify(llmResult, null, 2));


            // Format the llmResult into a chat message to persist to the database
            let newAssistantChatMessage = await formatLLMMessage("assistant",llmResult.content)            

            // If tool_calls are present, convert the tool call object to
            // an array to adhere to llm chat messaging format
            if (Object.keys(llmResult.tool_calls).length > 0 ) {
                // Format tool_calls object into an array
                newAssistantChatMessage.tool_calls = Object.values(llmResult.tool_calls);
            }
            
            console.info("newChatMessage before saving to database\n" + JSON.stringify(newAssistantChatMessage, null, 2));    

            // Save LLM result prompt to the database            
            await savePrompt(callSid, newAssistantChatMessage);            
            
            // If the LLM Results includes tool call(s), format the results 
            // and make the tool calls
            if (Object.keys(llmResult.tool_calls).length > 0 ) {
                
                // Send tool call(s) to handler function
                //let toolCallResult = await makeFunctionCalls(llmResult.tool_calls, callSid, sessionDetails);
                let toolCallResult;
                switch (sessionDetails.useCase) {
                    case "restaurant-ordering":
                        toolCallResult = await makeRestaurantOrderingToolCalls(llmResult.tool_calls, callSid, sessionDetails);
                        break;
                    case "apartment-search":
                        toolCallResult = await makeApartmentSearchToolCalls(llmResult.tool_calls, callSid, sessionDetails);
                        break;
                    default:
                        console.error("No tool calls handler found for use case: ", sessionDetails.useCase);
                        break;
                }

                

                // Upon successfully running the tool calls...
                if (toolCallResult) {

                    toolCallCompletion = true;

                    // Tool Call(s) successfully completed so 
                    // call the LLM a second time.
                    await prepareAndCallLLM({
                        callSid: callSid, 
                        sessionDetails: sessionDetails, 
                        socket: socket, 
                        body: null, 
                        toolCallCompletion: toolCallCompletion,
                        clientSocket: clientSocket
                    }); 

                }
            }

        } else if (body?.type === "interrupt") {

            /**
             * "interrupt" event sent by the ConversationRelay server when the user speaks 
             * before the text-to-speech has completed.
             * 
             * {
             *  "type" : "interrupt",
             *  "utteranceUntilInterrupt": "Life is a complex set of",
             *  "durationUntilInterruptMs": "460"
             * }
             * 
             * This implementation does not track interruptions.
             * 
             */

            // PUT records
            // pk = event.requestContext.connectionId 
            // sk = interrupt
            // ts = unix timestamp
     
        } else if (body?.type === "setup") {

            /**
             * "setup" event sent from ConversationRelay server as initial session message.
             * This event can be used for additional configuration for this call.
             * 
             * {
             *  "type": "setup",
             *  "sessionId": "",
             *  "callSid": "",
             *  "parentCallSid": null,
             *  "from": "+14085551212",
             *  "to": "+18881234567",
             *  "forwardedFrom": null,
             *  "callerName": null,
             *  "direction": "inbound",
             *  "callType": "PSTN",
             *  "callStatus": "IN-PROGRESS",
             *  "accountSid": "",
             *  "applicationSid": ""
             * }
             * 
             * This implementation does utilize the setup event.
             */
            
            // PUT record
            // pk = event.requestContext.connectionId 
            // sk = setup
            try {
                
                // Establish the connection in the DB and in the message handler functions...
                console.log("onConnectWebsocketHandler setup event called with callSid: ", callSid);
                //await onConnectWebsocketHandler(callSid);

            } catch (error) {
                
                console.error("Error in onConnectWebsocketHandler: ", error);

            }

        } else if (body?.type === "end") {

            /**
             * "end" event is the last message sent by the ConversationRelay server. This
             * message can be used for any "clean up" processing.
             * 
             * {
             *  "type" : "end",
             *  "handoffData": "{\"reasonCode\":\"live-agent-handoff\", \"reason\": \"The caller wants to talk to a real person\"}"
             * }
             * 
             * This implementation does not use the end event.
             */

            // PUT record
            // pk = event.requestContext.connectionId 
            // sk = end
            
        }
    } catch (error) {
        console.log("defaultWebsocketHandler generated an error => ", error);
        throw new Error(error); 
    }
};